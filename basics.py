from datetime import datetime

string1 = "FastEthernet"

string1.upper()
# 'FASTETHERNET'

string1.lower()
# 'fastethernet'

string1.swapcase()
# 'fASTeTHERNET'

string2 = "tunnel 0"

string2.capitalize()
# 'Tunnel 0'

# Очень важно обращать внимание на то, что часто методы возвращают преобразованную строку. И, значит, надо не забыть присвоить ее какой-то переменной (можно той же).
string1 = string1.upper()
# print(string1)
# FASTETHERNET


string1 = "Hello, hello, hello, hello"
string1.count("hello")  # 3
string1.count("ello")  # 4
string1.count("l")  # 8


string1 = "interface FastEthernet0/1"
string1.find("Fast")  # 10
string1[string1.find("Fast") : :]  # 'FastEthernet0/1'


string1 = "FastEthernet0/1"
string1.startswith("Fast")  # True
string1.startswith("fast")  # False
string1.endswith("0/1")  # True
string1.endswith("0/2")  # False


string1 = "FastEthernet0/1"
string1.replace("Fast", "Gigabit")  # 'GigabitEthernet0/1'


string1 = "\n\tinterface FastEthernet0/1\n"
# print(string1)
#
# interface FastEthernet0/1
#

# print(string1.strip())
# 'interface FastEthernet0/1'
# =
# =
# =
# =
# =
# Метод split
#
# Метод split() разбивает строку на части, используя как разделитель какой-то символ (или символы) и возвращает список строк:

string1 = "switchport trunk allowed vlan 10,20,30,100-200"
commands = string1.split()
# print(commands)  # ['switchport', 'trunk', 'allowed', 'vlan', '10,20,30,100-200']

# По умолчанию в качестве разделителя используются пробельные символы (пробелы, табы, перевод строки), но в скобках можно указать любой разделитель:
vlans = commands[-1].split(",")
# print(vlans)  # ['10', '20', '30', '100-200']


# Метод join
#
# Метод join() позволяет объеденить список, кортеж или словарь в строку разделяя ее елементы другой строкой.

myTuple = ("John", "Peter", "Vicky")
x = "-".join(myTuple)
# print(x)  # John-Peter-Vicky


# Метод format
#
# Метод format() позволяет подставлять в отмеченные в строке области символами «{}» значени из списка аргументов

# например:

price = 49
txt = "The price is {} dollars"
# print(txt.format(price))

# Так же можно указать тип подставлемых значений:

# Строковые занчения
"{} {}".format("one", "two")  # one two

# Числовые значения
"{} {}".format(1, 2)  # 1 2

# порядок значений можно указывать
"{1} {0}".format("one", "two")  # two one


# Можно так же подставлять значения классов
class Data(object):

    def __str__(self):
        return "str"

    def __repr__(self):
        return "repr"


"{0!s} {0!r}".format(Data())  # str repr

# Отступы и выравнивания
# по правому краю
"{:>10}".format("test")  # test

# по левому краю
"{:_<10}".format("test")  # test______

# по центру
"{:^10}".format("test")  # test

# срезы
"{:.5}".format("xylophone")  # xylop

# срезы и отступы
"{:10.5}".format("xylophone")  # xylop

# числа
"{:d}".format(42)  # 42
"{:f}".format(3.141592653589793)  # 3.141593

# числа и отступы
"{:4d}".format(42)  # 42
"{:06.2f}".format(3.141592653589793)  # 003.14
"{:04d}".format(42)  # 0042

# знаковые числа
"{:+d}".format(42)  # +42
"{: d}".format((-23))  # -23
"{: d}".format(42)  # 42
"{:=5d}".format((-23))  # -  23
"{:=+5d}".format(23)  # +  23

# можно вставлять значения по именам
data = {"first": "Hodor", "last": "Hodor!"}
"{first} {last}".format(**data)  # Hodor Hodor!
"{first} {last}".format(first="Hodor", last="Hodor!")  # Hodor Hodor!

# Формат даты и времени

"{:%Y-%m-%d %H:%M}".format(datetime(2001, 2, 3, 4, 5))  # 2001-02-03 04:05

# =
# =
# =
# =
# =
# =
# =
# =

# 1.4. Списки

# Списки – это изменяемые упорядоченные последовательности произвольных объектов. Списки создаются посредством заключения элементов списка в квадратные скобки

names = ["Dave", "Mark", "Ann", "Phil"]

# Элементы списка индексируются целыми числами, первый элемент списка имеет индекс, равный нулю. Для доступа к отдельным элементам списка используется оператор индексирования

a = names[2]  # Вернет третий элемент списка, “Ann”
names[0] = "Jeff"  # Запишет имя “Jeff” в первый элемент списка

# С помощью оператора среза можно извлекать и изменять целые фрагменты списков:

b = names[0:2]  # Вернет [“Jeff”, “Mark”]
c = names[2:]  # Вернет [“Thomas”, “Ann”, “Phil”, “Paula”]
names[1] = "Jeff"  # Во второй элемент запишет имя ‘Jeff’
# Заменит первые два элемента списком справа.
names[0:2] = ["Dave", "Mark", "Jeff"]

# Списки могут содержать объекты любого типа, числа, строки, другие списки

a = [1, "Dave", 3.14, ["Mark", 7, 9, [100, 101]], 10]

# Списки так же как и строки можно конкатинировать между собоой

[1, 2, 3] + [4, 5]  # Создаст список [1,2,3,4,5]

# 1.4.1. Меторы для работы со списками

# List()

# создаст пустой список, либо преобразует аргументы в список

l = list("1234567890")
# print(l)  # [1,2,3,4,5,6,7,8,9,0]

# join()

# собирает список строк в одну строку с разделителем, который указан перед join:

a = ["10", "20", "30"]
# print(",".join(a))  # 10,20,30

# Примечание
#
# Метод join на самом деле относится к строкам, но так как значение ему надо передавать как список, он рассматривается тут.
#
# append()
#
# добавляет в конец списка указанный элемент:

a = ["10", "20", "30", "100-200"]
a.append("300")
# print(a)  # ['10', '20', '30', '100-200', '300']

# extend()

# Если нужно объединить два списка, то можно использовать два способа: метод extend() и операцию сложения.
#
# У этих способов есть важное отличие - extend меняет список, к которому применен метод, а суммирование возвращает новый список, который состоит из двух.

a = ["10", "20", "30", "100-200"]
b = ["300", "400", "500"]
a.extend(b)
# print(a)  # ['10', '20', '30', '100-200', '300', '400', '500']


# pop()

# удаляет элемент, который соответствует указанному номеру. Но, что важно, при этом метод возвращает этот элемент:

a = ["10", "20", "30", "100-200"]
a.pop(-1)  # '100-200'
# print(a)  # ['10', '20', '30']

# Примечание
#
# Без указания номера удаляется последний элемент списка.
#
# remove()

# удаляет указанный элемент и не возвращает удаленный элемент:

a = ["10", "20", "30", "100-200"]
a.remove("20")
# print(a)  # ['10', '30', '100-200']

# Примечание
#
# В методе remove надо указывать сам элемент, который надо удалить, а не его номер в списке. Если указать номер элемента, возникнет ошибка:

# insert()

# позволяет вставить элемент на определенное место в списке:

a = ["10", "20", "30", "100-200"]
a.insert(1, "15")
# print(a)  # ['10', '15', '20', '30', '100-200']

# sort()

# сортирует список на месте:

a = [1, 50, 10, 15]
a.sort()
# print(a)  # [1, 10, 15, 50]


n = "Qwer"
l = ["qwe", "asd", n]
a = {n: 12}
# print(a["Qwer"])

london = {
    "id": 1,
    "name": "London",
    "it_vlan": 320,
    "user_vlan": 1010,
    "mngmt_vlan": 99,
    "to_name": None,
    "to_id": None,
    "port": "G1/0/11",
}
# print(london.keys())


D = {"food": "Spam", "quantity": 4, "color": "pink"}
D["food"]  # Извлечь значение, связанное с ключом 'food' 'Spam'
D["quantity"] += 1  # Добавить 1 к значению, связанному с ключом 'quantity'
# print(D)
# {'color': 'pink', 'food': 'Spam', 'quantity': 5}


D = {}
D["name"] = "Bob"
D["job"] = "dev"
D["age"] = 40
# print(D)
# {'*:age 40, 'job': 'dev', 'name': 'Bob'}
# print(D["name"])
# Bob


london_co = {
    "r1": {
        "hostname": "london_r1",
        "location": "21 New Globe Walk",
        "vendor": "Cisco",
        "model": "4451",
        "ios": "15.4",
        "ip": "10.255.0.1",
    },
    "r2": {
        "hostname": "london_r2",
        "location": "21 New Globe Walk",
        "vendor": "Cisco",
        "model": "4451",
        "ios": "15.4",
        "ip": "10.255.0.2",
    },
    "sw1": {
        "hostname": "london_sw1",
        "location": "21 New Globe Walk",
        "vendor": "Cisco",
        "model": "3850",
        "ios": "3.6.XE",
        "ip": "10.255.0.101",
    },
}


# print(london_co["r1"]["ios"])  #'15.4'
# print(london_co["r1"]["model"])  #'4451'
# print(london_co["sw1"]["ip"])  #'10.255.0.101'


# 1.6. Методы для работы со словарями

# clear()

# позволяет очистить словарь:

# copy()

# создает полную копию словаря

london = {"name": "London1", "location": "London Str", "vendor": "Cisco"}
london2 = london.copy()
id(london)  # 25524512
id(london2)  # 25563296
london["vendor"] = "Juniper"
london2["vendor"]  # 'Cisco'

# Примечание

# Если указать, что один словарь равен другому, то london2 будет ссылкой на словарь.
# И при изменениях словаря london меняется и словарь london2, так как это ссылки на один и тот же объект.


# get()

# запрашивает ключ, и если его нет, вместо ошибки возвращает None.

london = {"name": "London1", "location": "London Str", "vendor": "Cisco"}
# print(london.get("ios"))  # None

# Метод get() позволяет также указывать другое значение вместо None
# print(london.get("ios", "Ooops"))  # Ooops


# setdefault()

# ищет ключ, и если его нет, вместо ошибки создает ключ со значением None, если ключ есть, setdefault возвращает значение, которое ему соответствует:

london = {"name": "London1", "location": "London Str", "vendor": "Cisco"}
ios = london.setdefault("ios")
# print(ios)  # None
# {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco', 'ios': None}
london
london.setdefault("name")  # 'London1'

# Второй аргумент позволяет указать, какое значение должно соответствовать ключу
model = london.setdefault("model", "Cisco3580")
# print(model)  # Cisco3580
london
{
    "name": "London1",
    "location": "London Str",
    "vendor": "Cisco",
    "ios": None,
    "model": "Cisco3580",
}

# Метод setdefault заменяет такую конструкцию:
# if key in london:
#      value = london[key]
# else:
#      london[key] = 'somevalue'
#      value = london[key]


# keys(), values(), items()

# Все три метода возвращают специальные объекты view, которые отображают ключи, значения и пары ключ-значение словаря соответственно.
#
# Очень важная особенность view заключается в том, что они меняются вместе с изменением словаря. И фактически они лишь дают способ посмотреть на соответствующие объекты, но не создают их копию.

london = {"name": "London1", "location": "London Str", "vendor": "Cisco"}
keys = london.keys()
# print(keys)
# dict_keys(['name', 'location', 'vendor'])

# Сейчас переменной keys соответствует view dict_keys, в котором три ключа: name, location и vendor.
# Но, если мы добавим в словарь еще одну пару ключ-значение, объект keys тоже поменяется:
london["ip"] = "10.1.1.1"
keys
# dict_keys(['name', 'location', 'vendor', 'ip'])

# Если нужно получить обычный список ключей, который не будет меняться с изменениями словаря, достаточно конвертировать view в список:
list_keys = list(london.keys())
list_keys
# ['name', 'location', 'vendor', 'ip']


# del()

# Удаляет ключ и значение

london = {"name": "London1", "location": "London Str", "vendor": "Cisco"}
del london["name"]
london
# {'location': 'London Str', 'vendor': 'Cisco'}

# update()

# Позволяет добавлять в словарь содержимое другого словаря:

r1 = {"name": "London1", "location": "London Str"}
r1.update({"vendor": "Cisco", "ios": "15.2"})
r1
# {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco', 'ios': '15.2'}

# Аналогичным образом можно обновить значения:
r1.update({"name": "london-r1", "ios": "15.4"})
r1
"""
{'name': 'london-r1',
 'location': 'London Str',
 'vendor': 'Cisco',
 'ios': '15.4'}
"""


# 1.7. Кортежи

# Объект кортежа примерно похож на список, который нельзя изменять — кортежи являются последовательностями подобно спискам,
# но они неизменяемые подобно строка­ ми. Функционально они используются для представления фиксированных коллекций элементов:
# скажем, компонентов специфической даты в календаре. Синтаксически они записываются в круглых,
# а не квадратных скобках и поддерживают произвольные типы, произвольное вложение и обычные операции над последовательностями:

T = (1, 2, 3, 4)  # Кортеж из 4 элементов
# len(Т)  # Длина 4
# Т + (5, б)       # Конкатенация (1, 2, 3, 4, 5, 6)
# Т[О]             # Индексация, нарезание и т.д.

# Примечание

# Главное отличие кортежей заключается в том, что после создания их нельзя из­ менять,
# т.е. они являются неизменяемыми последовательностями (одноэлементные кортежи вроде приведенного ниже требуют хвостовой запятой): tuple2 = („password“,)

# Итак, зачем нам тип, который похож на список, но поддерживает меньше операций?
# Откровенно говоря, на практике кортежи применяются в целом не так часто, как списки,
# но весь смысл в их неизменяемости. Если вы передаете коллекцию объектов внутри своей программы в виде списка,
# тогда он может быть модифицирован где угодно; если вы используете кортеж, то изменить его не удастся.
# То есть кортежи обеспечивают своего рода ограничение целостности, что удобно в программах, крупнее тех,
# которые мы будем писать здесь. Позже в книге мы еще обсудим кортежи, включая расширение, которое построено поверх них и называется именованными кортежами.


# 1.8. Множество

# Множество - это изменяемый неупорядоченный тип данных. В множестве всегда содержатся только уникальные элементы.

# Множество в Python - это последовательность элементов, которые разделены между собой запятой и заключены в фигурные скобки.

# С помощью множества можно легко убрать повторяющиеся элементы:

cities = ["Санкт-Петербург", "Хабаровск", "Казань", "Санкт-Петербург", "Казань"]
un_cities = set(cities)
# for city in un_cities:
# print("Один мой друг живёт в городе " + city)

"""
Один мой друг живёт в городе Хабаровск
Один мой друг живёт в городе Санкт-Петербург
Один мой друг живёт в городе Казань
"""

# Множества полезны тем, что с ними можно делать различные операции и находить объединение множеств, пересечение и так далее.

# Объединение множеств можно получить с помощью метода union() или оператора |:

vlans1 = {10, 20, 30, 50, 100}
vlans2 = {100, 101, 102, 102, 200}
vlans1.union(vlans2)  # {10, 20, 30, 50, 100, 101, 102, 200}
vlans1 | vlans2  # {10, 20, 30, 50, 100, 101, 102, 200}

# Пересечение множеств можно получить с помощью метода intersection() или оператора &
vlans1 = {10, 20, 30, 50, 100}
vlans2 = {100, 101, 102, 102, 200}
vlans1.intersection(vlans2)  # {100}
vlans1 & vlans2  # {100}

# Предупреждение

# Нельзя создать пустое множество с помощью литерала (так как в таком случае это будет не множество, а словарь): set1 = {} type(set1) #dict

# Но пустое множество можно создать таким образом set2 = set() type(set2) #set


# 1.9. Методы для работы с множествами

# add()

# добавляет элемент во множество:

set1 = {10, 20, 30, 40}
set1.add(50)
set1  # {10, 20, 30, 40, 50}

# discard()

# позволяет удалять элементы, не выдавая ошибку, если элемента в множестве нет

set1  # {10, 20, 30, 40, 50}
set1.discard(55)
set1  # {10, 20, 30, 40, 50}
set1.discard(50)
set1  # {10, 20, 30, 40}
# print(set1.discard(5))
# print(set1.remove(5))

# clear()

# очищает множество

set1 = {10, 20, 30, 40}
set1.clear()
set1  # set()


# 1.10. Булевы значения
#
# Булевы значения в Python это две константы True и False.
#
# В Python истинными и ложными значениями считаются не только True и False.
#
#     истинное значение:
#
#         любое ненулевое число
#
#         любая непустая строка
#
#         любой непустой объект
#
#     ложное значение:
#
#         0
#
#         None
#
#         пустая строка
#
#         пустой объект
#
# Остальные истинные и ложные значения, как правило, логически следуют из условия.

# Для проверки булевого значения объекта, можно воспользоваться bool:

items = [1, 2, 3]
empty_list = []
bool(empty_list)  # False
bool(items)  # True
bool(0)  # False
bool(1)  # True


# 1.11. Преобразование типов
#
# В Python есть несколько полезных встроенных функций, которые позволяют преобразовать данные из одного типа в другой.

int()

# преобразует строку в int:

int("10")  # 10
int(
    "11111111",
    2,
    # 255  С помощью функции int можно преобразовать и число в двоичной записи в десятичную (двоичная запись должна быть в виде строки)
)

# bin()

# Преобразовать десятичное число в двоичный формат можно с помощью bin():

bin(10)  # '0b1010'
bin(255)  # '0b11111111'

# hex()

# Аналогичная функция есть и для преобразования в шестнадцатеричный формат:

hex(10)  # '0xa'
hex(255)  # '0xff'

# list()

# Функция list() преобразует аргумент в список:

list("string")  # ['s', 't', 'r', 'i', 'n', 'g']
list({1, 2, 3})  # [1, 2, 3]
list((1, 2, 3, 4))  # [1, 2, 3, 4

# set()

# Функция set() преобразует аргумент в множество:

set([1, 2, 3, 3, 4, 4, 4, 4])  # {1, 2, 3, 4}
set((1, 2, 3, 3, 4, 4, 4, 4))  # {1, 2, 3, 4}
set("string string")  # {' ', 'g', 'i', 'n', 'r', 's', 't'}

# tuple()

# Функция tuple() преобразует аргумент в кортеж:

tuple([1, 2, 3, 4])  # (1, 2, 3, 4)
tuple({1, 2, 3, 4})  # (1, 2, 3, 4)
tuple("string")  # ('s', 't', 'r', 'i', 'n', 'g')

# str()

# Функция str() преобразует аргумент в строку:

str(10)  # '10'


# 1.12. Проверка типов

# isdigit()

# Проверяет, сосоит ли строка из одних только цифр

"a".isdigit()  # False
"a10".isdigit()  # False
"10".isdigit()  # True

# isalpha()

# Проверяет, состоит ли строка из одних букв:

"a".isalpha()  # True
"a100".isalpha()  # False
"a--  ".isalpha()  # False
"a ".isalpha()  # False

# isalnum()

# позволяет проверить, состоит ли строка из букв или цифр:

"a".isalnum()  # True
"a10".isalnum()  # True

# type()

# Иногда, в зависимости от результата, библиотека или функция может выводить разные типы объектов. Например,
# если объект один, возвращается строка, если несколько, то возвращается кортеж.
#
# Нам же надо построить ход программы по-разному, в зависимости от того, была ли возвращена строка или кортеж.
#
# В этом может помочь функция type():

type("string")  # str
type("string") is str  # True

# Аналогично с кортежем (и другими типами данных):
type((1, 2, 3))  # tuple
type((1, 2, 3)) is tuple  # True
type((1, 2, 3)) is list  # False


# 1.12. Проверка типов

# isdigit()

# Проверяет, сосоит ли строка из одних только цифр

"a".isdigit()  # False
"a10".isdigit()  # False
"10".isdigit()  # True

# isalpha()

# Проверяет, состоит ли строка из одних букв:

"a".isalpha()  # True
"a100".isalpha()  # False
"a--  ".isalpha()  # False
"a ".isalpha()  # False

# isalnum()

# позволяет проверить, состоит ли строка из букв или цифр:

"a".isalnum()  # True
"a10".isalnum()  # True

# type()

# Иногда, в зависимости от результата, библиотека или функция может выводить разные типы объектов. Например,
# если объект один, возвращается строка, если несколько, то возвращается кортеж.

# Нам же надо построить ход программы по-разному, в зависимости от того, была ли возвращена строка или кортеж.

# В этом может помочь функция type():

type("string")  # str
type("string") is str  # True

# Аналогично с кортежем (и другими типами данных):
type((1, 2, 3))  # tuple
type((1, 2, 3)) is tuple  # True
type((1, 2, 3)) is list  # False


# 1.13. Файлы

# Объекты файлов являются главным интерфейсом к внешним файлам на компью­ тере.
# Они могут применяться для чтения и записи текстовых заметок, аудиоклипов, документов Excel,
# сохраненных сообщений электронной почты и всего того, что вы в итоге сохранили на своем компьютере.
# Файлы относятся к основным типам, но они кое в чем своеобразны —
# специфический литеральный синтаксис для их создания от­ сутствует,
# Взамен, чтобы создать объект файла, необходимо вызвать встроенную фун­ кцию open,
# передав ей в виде строк имя внешнего файла и необязательный режим обработки.

# Например, для создания выходного текстового файла понадобится передать его имя и строку
# режима обработки ’ w ’, чтобы записывать данные:

# f = open("data.txt", "w")  # Создать новый файл в режиме записи ('w')
# f.write("Hello\n")  # Записать в него строки символов
# f.write("world\n")  # Возвратить количество записанных элементов
# f.close()  # Закрыть для сбрасывания буферов вывода на диск


# Код создает файл в текущем каталоге и записывает в него текст (имя файла мо­ жет содержать
# полный путь к каталогу,
# если нужно получить доступ к файлу где-то в другом месте на компьютере). Чтобы прочитать то,
# что было записано,
# необходимо повторно открыть файл в режиме обработки ’ г ’ для чтения текстового ввода
# (он выбирается по умолчанию,
# если в вызове строка режима не указана). Затем следует про­ читать содержимое файла в
# строку и отобразить ее.
# В сценарии содержимое файла всегда будет строкой независимо от типа находящихся в нем данных:

f = open("data.txt")  # 'г' (чтение) - стандартный режим обработки
text = f.read()  # Прочитать все содержимое файла в строку
text  # 'Hello\nworld\n'
# print(text)  # print интерпретирует управляющие символы
# Hello
# world
text.split()  # Содержимое файла - всегда строка
# ['Hello', 'world']

# Примечание

# Обратите внимание, что для того что бы прочесть все строки из файла, нам нужно обернуть
# функцию чтения в цикл
# for line in open(’data.txt’): print(line)

# так же не забывайте закрывать файл после операции чтения или записи f.close


# import random

# a = random.randrange(1, 10)
# b = int(input("Enter a number: "))
# if a == b:
#     print("You win")
# else:
#     print("You lose")


# number = 23
# running = True

# while running:
#     guess = int(input("Введите целое число : "))

#     if guess == number:
#         print("Поздравляю, вы угадали.")
#         running = False  # это останавливает цикл while
#     elif guess < number:
#         print("Нет, загаданное число немного больше этого.")
#     else:
#         print("Нет, загаданное число немного меньше этого.")
# else:
#     print("Цикл while закончен.")
#     # Здесь можете выполнить всё что вам ещё нужно

# print("Завершение.")


# for i in range(1, 6):
#     print(i)
# else:
#     print("Цикл for закончен")


# while True:
#     s = input("Введите что-нибудь : ")
#     if s == "выход":
#         break
#     print("Длина строки:", len(s))
# print("Завершение")


# while true:
#     s = input('введите что-нибудь : ')
#     if s == 'выход':
#         break
#     if len(s) < 3:
#         print('слишком мало')
#         continue
#     print('введённая строка достаточной длины')
# разные другие действия здесь...


# Пример - 1
# for i in range(1, 20, 2):  #функция range() указывает начальное значение, конечное значение и шаг.
#     print('{:^20}'.format('*' * i))  # Печатаем символ выравнивая его по центру


# x = 50


# def func(x):
#     print("x равен", x)
#     x = 2
#     print("Замена локального x на", x)
#
#
# func(x)
# print("x по-прежнему", x)


# x = 50
#
#
# def func():
#     global x
#
#     print("x равно", x)
#     x = 2
#     print("Заменяем глобальное значение x на", x)
#
#
# func()
# print("Значение x составляет", x)


# def func_outer():
#     x = 2
#     print("x равно", x)
#
#     def func_inner():
#         nonlocal x
#         x = 5
#
#     func_inner()
#     print("Локальное x сменилось на", x)
#
#
# func_outer()


# def say(message, times=1):
#     print(message * times)
#
#
# say("Привет")
# say("Мир", 5)


# def func(a, b=5, c=10):
#     print("a равно", a, ", b равно", b, ", а c равно", c)
#
#
# func(3, 7)
# func(25, c=24)
# func(c=50, a=100)


# def total(a=5, *numbers, **phonebook):
#     print("a", a)
#
#     # проход по всем элементам кортежа
#     for single_item in numbers:
#         print("single_item", single_item)
#
#     # проход по всем элементам словаря
#     for first_part, second_part in phonebook.items():
#         print(first_part, second_part)
#
#
# print(total(10, 1, 2, 3, Jack=1123, John=2231, Inge=1560))


# def total(initial=5, *numbers, extra_number):
#     count = initial
#     for number in numbers:
#         count += number
#     count += extra_number
#     print(count)
#
#
# total(10, 1, 2, 3, extra_number=50)
# total(10, 1, 2, 3)
# Вызовет ошибку, поскольку мы не указали значение
# аргумента по умолчанию для 'extra_number'.


# def maximum(x, y):
#     if x > y:
#         return x
#     elif x == y:
#         return "Числа равны."
#     else:
#         return y
#
#
# print(maximum(3, 3))


# def printMax(x, y):
#     """Выводит максимальное из двух чисел.
#
#     Оба значения должны быть целыми числами."""
#     x = int(x)  # конвертируем в целые, если возможно
#     y = int(y)
#
#     if x > y:
#         print(x, "наибольшее")
#     else:
#         print(y, "наибольшее")
#
#
# printMax(3, 5)
# print(printMax.__doc__)


# summary = lambda x, y: x + y
# print(summary(1, 2))
#
# (lambda x, y: print(x + y))(3, 2)
# l1 = [1, 2, 3]
# l2 = [4, 5, 6]
# print(list(map(lambda x, y: x + y, l1, l2)))
#
# res = tuple(x for x in range(10))
# res1 = (x for x in range(10))
# res2 = [[x, j] for x in range(10) for j in range(10)]
# res3 = {x: y for x, y in zip(l1, l2)}
#
#
# my_list1 = [(x, y) for x in range(3) for y in range(2)]
#
# print(my_list1)
#
# my_list2 = [(x, y) if x < y else (y, x) for x in range(5) for y in range(3)]
#
# print(my_list2)


# print(res)
# print(*res1)
# print(res2)
# print(res3)
#
#
# a = 10
# b = True if a > 5 else False
# print(b)


# import random

# n = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
# random.shuffle(n)
# print(n)


# print(random.choice("dsqwdfewqrwsaf"))
# print(random.choice([1, 2, 3, 4, 5]))
# print(random.choice(["q", "e", "t"]))


# numbers = [1, 4, 3, 2, 5, 6, 9, 0, 7, 8]

# print(random.sample(numbers, 3))
# print(random.sample(numbers, 6))
# print(random.sample(numbers, 9))


class Cat:
    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return f"{self.__class__}: {self.name}"

    def __str__(self):
        return f"{self.name}"


cat = Cat("Васька")
print(repr(cat))


class Point:
    def __init__(self, *args):
        self.__coords = args

    def __len__(self):
        return len(self.__coords)

    def __abs__(self):
        return list(map(abs, self.__coords))


p = Point(-1, 2)
print(len(p))
print(abs(p))
